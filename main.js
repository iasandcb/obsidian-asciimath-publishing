 /*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AsciiMathPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// node_modules/.pnpm/asciimath-parser@0.6.10/node_modules/asciimath-parser/dist/index.js
var m = ((x) => (x.NumberLiteral = "NumberLiteral", x.StringLiteral = "StringLiteral", x.Text = "Text", x.Const = "Const", x.OperatorOA = "OperatorA", x.OperatorOAB = "OperatorOAB", x.OperatorAOB = "OperatorAOB", x.OperatorMinus = "OperatorMinus", x.OperatorAO = "OperatorAO", x.OperatorO2 = "OperatorOptionalTwoParams", x.OperatorSup = "OperatorSup", x.OperatorPartial = "OperatorPartial", x.LParen = "LParen", x.RParen = "RParen", x.Paren = "Paren", x.Align = "Align", x.Split = "Split", x.None = "None", x))(m || {});
var f = /* @__PURE__ */ new Map([["alpha", { type: "Const", tex: "\\alpha" }], ["beta", { type: "Const", tex: "\\beta" }], ["gamma", { type: "Const", tex: "\\gamma" }], ["Gamma", { type: "Const", tex: "\\Gamma" }], ["delta", { type: "Const", tex: "\\delta" }], ["Delta", { type: "Const", tex: "\\Delta" }], ["epsi", { type: "Const", tex: "\\varepsilon" }], ["epsilon", { type: "Const", tex: "\\epsilon" }], ["varepsilon", { type: "Const", tex: "\\varepsilon" }], ["zeta", { type: "Const", tex: "\\zeta" }], ["eta", { type: "Const", tex: "\\eta" }], ["theta", { type: "Const", tex: "\\theta" }], ["Theta", { type: "Const", tex: "\\Theta" }], ["vartheta", { type: "Const", tex: "\\vartheta" }], ["iota", { type: "Const", tex: "\\iota" }], ["kappa", { type: "Const", tex: "\\kappa" }], ["lambda", { type: "Const", tex: "\\lambda" }], ["Lambda", { type: "Const", tex: "\\Lambda" }], ["mu", { type: "Const", tex: "\\mu" }], ["nu", { type: "Const", tex: "\\nu" }], ["xi", { type: "Const", tex: "\\xi" }], ["Xi", { type: "Const", tex: "\\Xi" }], ["pi", { type: "Const", tex: "\\pi" }], ["Pi", { type: "Const", tex: "\\Pi" }], ["rho", { type: "Const", tex: "\\rho" }], ["sigma", { type: "Const", tex: "\\sigma" }], ["Sigma", { type: "Const", tex: "\\Sigma" }], ["tau", { type: "Const", tex: "\\tau" }], ["upsilon", { type: "Const", tex: "\\upsilon" }], ["phi", { type: "Const", tex: "\\phi" }], ["varphi", { type: "Const", tex: "\\varphi" }], ["varPhi", { type: "Const", tex: "\\varPhi" }], ["phv", { type: "Const", tex: "\\varphi" }], ["Phv", { type: "Const", tex: "\\varPhi" }], ["Phi", { type: "Const", tex: "\\Phi" }], ["chi", { type: "Const", tex: "\\chi" }], ["psi", { type: "Const", tex: "\\psi" }], ["Psi", { type: "Const", tex: "\\Psi" }], ["omega", { type: "Const", tex: "\\omega" }], ["Omega", { type: "Const", tex: "\\Omega" }], ["***", { type: "Const", tex: "\\star" }], ["star", { type: "Const", tex: "\\star" }], ["**", { type: "Const", tex: "\\ast" }], ["ast", { type: "Const", tex: "\\ast" }], ["*", { type: "Const", tex: "\\cdot" }], ["cdot", { type: "Const", tex: "\\cdot" }], ["//", { type: "Const", tex: "{/}" }], ["\\\\", { type: "Const", tex: "\\backslash" }], ["setminus", { type: "Const", tex: "\\setminus" }], ["xx", { type: "Const", tex: "\\times" }], ["|><", { type: "Const", tex: "\\ltimes" }], ["><|", { type: "Const", tex: "\\rtimes" }], ["|><|", { type: "Const", tex: "\\bowtie" }], ["-:", { type: "Const", tex: "\\div" }], ["@", { type: "Const", tex: "\\circ" }], ["o+", { type: "Const", tex: "\\oplus" }], ["ox", { type: "Const", tex: "\\otimes" }], ["o.", { type: "Const", tex: "\\odot" }], ["sum", { type: "Const", tex: "\\sum" }], ["prod", { type: "Const", tex: "\\prod" }], ["^^", { type: "Const", tex: "\\wedge" }], ["^^^", { type: "Const", tex: "\\bigwedge" }], ["vv", { type: "Const", tex: "\\vee" }], ["vvv", { type: "Const", tex: "\\bigvee" }], ["nn", { type: "Const", tex: "\\cap" }], ["nnn", { type: "Const", tex: "\\bigcap" }], ["uu", { type: "Const", tex: "\\cup" }], ["uuu", { type: "Const", tex: "\\bigcup" }], ["!=", { type: "Const", tex: "\\ne" }], ["lt", { type: "Const", tex: "<" }], ["<<", { type: "Const", tex: "\\ll" }], [">>", { type: "Const", tex: "\\gg" }], ["<=", { type: "Const", tex: "\\leqslant" }], ["le", { type: "Const", tex: "\\le" }], ["gt", { type: "Const", tex: ">" }], [">=", { type: "Const", tex: "\\geqslant" }], ["ge", { type: "Const", tex: "\\ge" }], ["-<", { type: "Const", tex: "\\prec" }], [">-", { type: "Const", tex: "\\succ" }], ["-<=", { type: "Const", tex: "\\preceq" }], [">-=", { type: "Const", tex: "\\succeq" }], ["in", { type: "Const", tex: "\\in" }], ["!in", { type: "Const", tex: "\\notin" }], ["sub", { type: "Const", tex: "\\subset" }], ["sup", { type: "Const", tex: "\\supset" }], ["sube", { type: "Const", tex: "\\subseteq" }], ["supe", { type: "Const", tex: "\\supseteq" }], ["-=", { type: "Const", tex: "\\equiv" }], ["~=", { type: "Const", tex: "\\cong" }], ["~", { type: "Const", tex: "\\sim" }], ["~~", { type: "Const", tex: "\\approx" }], ["\\#", { type: "Const", tex: "\\#" }], ["\\&", { type: "Const", tex: "\\&" }], ["\\@", { type: "Const", tex: "@" }], ["\\%", { type: "Const", tex: "\\%" }], ["%", { type: "Const", tex: "\\%" }], ["\\_", { type: "Const", tex: "\\_" }], ["\\^", { type: "Const", tex: "\\^" }], ["\\$", { type: "Const", tex: "\\$" }], ["\\ ", { type: "Const", tex: "\\ " }], ["\\,", { type: "Const", tex: "\\," }], ["\\;", { type: "Const", tex: "\\;" }], ["\\:", { type: "Const", tex: "\\:" }], ["\\!", { type: "Const", tex: "\\!" }], ["enspace", { type: "Const", tex: "\\enspace" }], ["hspace", { type: "OperatorA", tex: "\\hspace{$1}", eatNext: true }], ["prop", { type: "Const", tex: "\\propto" }], ["comp", { type: "Const", tex: "\\complement" }], ["complement", { type: "Const", tex: "\\complement" }], [":=", { type: "Const", tex: "\\coloneqq" }], ["=:", { type: "Const", tex: "\\eqqcolon" }], ["if", { type: "Text", tex: "if\\quad" }], ["otherwise", { type: "Text", tex: "otherwise\\quad" }], ["and", { type: "Text", tex: " and " }], ["or", { type: "Text", tex: " or " }], ["not", { type: "Const", tex: "\\neg" }], ["=>", { type: "Const", tex: "\\implies" }], ["=/=>", { type: "Const", tex: "\\centernot\\implies" }], ["~>", { type: "Const", tex: "\\rightsquigarrow" }], ["-/->", { type: "Const", tex: "\\nrightarrow" }], ["<-/-", { type: "Const", tex: "\\nleftarrow" }], ["<-/->", { type: "Const", tex: "\\nleftrightarrow" }], ["<==", { type: "Const", tex: "\\;\\Longleftarrow\\;" }], ["<=>", { type: "Const", tex: "\\iff" }], ["<=/=>", { type: "Const", tex: "\\centernot\\iff" }], ["iff", { type: "Const", tex: "\\iff" }], ["!iff", { type: "Const", tex: "\\centernot\\iff" }], ["AA", { type: "Const", tex: "\\forall" }], ["EE", { type: "Const", tex: "\\exists" }], ["_|_", { type: "Const", tex: "\\bot" }], ["TT", { type: "Const", tex: "\\top" }], ["|--", { type: "Const", tex: "\\vdash" }], ["|==", { type: "Const", tex: "\\models" }], ["int", { type: "Const", tex: "\\int" }], ["oint", { type: "Const", tex: "\\oint" }], ["del", { type: "Const", tex: "\\partial" }], ["grad", { type: "Const", tex: "\\nabla" }], ["+-", { type: "Const", tex: "\\pm" }], ["-+", { type: "Const", tex: "\\mp" }], ["O/", { type: "Const", tex: "\\varnothing" }], ["oo", { type: "Const", tex: "\\infty" }], ["aleph", { type: "Const", tex: "\\aleph" }], ["...", { type: "Const", tex: "\\ldots" }], [":.", { type: "Const", tex: "\\therefore" }], [":'", { type: "Const", tex: "\\because" }], ["/_", { type: "Const", tex: "\\angle" }], ["/_\\", { type: "Const", tex: "\\triangle" }], ["quad", { type: "Const", tex: "\\quad" }], ["qquad", { type: "Const", tex: "\\qquad" }], ["cdots", { type: "Const", tex: "\\cdots" }], ["vdots", { type: "Const", tex: "\\vdots" }], ["ddots", { type: "Const", tex: "\\ddots" }], ["diamond", { type: "Const", tex: "\\diamond" }], ["Lap", { type: "Const", tex: "\\mathscr{L}" }], ["square", { type: "Const", tex: "\\square" }], ["|__", { type: "LParen", tex: "\\lfloor" }], ["__|", { type: "RParen", tex: "\\rfloor" }], ["|~", { type: "LParen", tex: "\\lceil" }], ["~|", { type: "RParen", tex: "\\rceil" }], ["CC", { type: "Const", tex: "\\mathbb{C}" }], ["NN", { type: "Const", tex: "\\mathbb{N}" }], ["QQ", { type: "Const", tex: "\\mathbb{Q}" }], ["RR", { type: "Const", tex: "\\mathbb{R}" }], ["ZZ", { type: "Const", tex: "\\mathbb{Z}" }], ["'", { type: "Const", tex: "^{\\prime}" }], ["''", { type: "Const", tex: "^{\\prime\\prime}" }], ["'''", { type: "Const", tex: "^{\\prime\\prime\\prime}" }], ["lim", { type: "Const", tex: "\\lim" }], ["sin", { type: "Const", tex: "\\sin" }], ["cos", { type: "Const", tex: "\\cos" }], ["tan", { type: "Const", tex: "\\tan" }], ["sinh", { type: "Const", tex: "\\sinh" }], ["cosh", { type: "Const", tex: "\\cosh" }], ["tanh", { type: "Const", tex: "\\tanh" }], ["cot", { type: "Const", tex: "\\cot" }], ["sec", { type: "Const", tex: "\\sec" }], ["csc", { type: "Const", tex: "\\csc" }], ["arcsin", { type: "Const", tex: "\\arcsin" }], ["arccos", { type: "Const", tex: "\\arccos" }], ["arctan", { type: "Const", tex: "\\arctan" }], ["coth", { type: "Const", tex: "\\coth" }], ["sech", { type: "Const", tex: "\\operatorname{sech}" }], ["csch", { type: "Const", tex: "\\operatorname{csch}" }], ["exp", { type: "Const", tex: "\\exp" }], ["log", { type: "Const", tex: "\\log" }], ["ln", { type: "Const", tex: "\\ln" }], ["det", { type: "Const", tex: "\\det" }], ["dim", { type: "Const", tex: "\\dim" }], ["gcd", { type: "Const", tex: "\\gcd" }], ["lcm", { type: "Const", tex: "\\operatorname{lcm}" }], ["min", { type: "Const", tex: "\\min" }], ["max", { type: "Const", tex: "\\max" }], ["Sup", { type: "Const", tex: "\\sup" }], ["inf", { type: "Const", tex: "\\inf" }], ["mod", { type: "Const", tex: "\\operatorname{mod}" }], ["sgn", { type: "Const", tex: "\\operatorname{sgn}" }], ["arg", { type: "Const", tex: "\\operatorname{arg}" }], ["Arg", { type: "Const", tex: "\\operatorname{Arg}" }], ["abs", { type: "OperatorA", tex: "\\left| $1 \\right|" }], ["norm", { type: "OperatorA", tex: "\\| $1 \\|" }], ["floor", { type: "OperatorA", tex: "\\left\\lfloor $1 \\right\\rfloor" }], ["ceil", { type: "OperatorA", tex: "\\left\\lceil $1 \\right\\rceil" }], ["uarr", { type: "Const", tex: "\\uparrow" }], ["uparrow", { type: "Const", tex: "\\uparrow" }], ["darr", { type: "Const", tex: "\\downarrow" }], ["downarrow", { type: "Const", tex: "\\downarrow" }], ["rarr", { type: "Const", tex: "\\rightarrow" }], ["rightarrow", { type: "Const", tex: "\\rightarrow" }], ["to", { type: "Const", tex: "\\to" }], ["->", { type: "Const", tex: "\\to" }], ["<-", { type: "Const", tex: "\\gets" }], [">->", { type: "Const", tex: "\\rightarrowtail" }], ["->>", { type: "Const", tex: "\\twoheadrightarrow" }], [">->>", { type: "Const", tex: "\u2916" }], ["|->", { type: "Const", tex: "\\mapsto" }], ["larr", { type: "Const", tex: "\\leftarrow" }], ["leftarrow", { type: "Const", tex: "\\leftarrow" }], ["harr", { type: "Const", tex: "\\leftrightarrow" }], ["rArr", { type: "Const", tex: "\\Rightarrow" }], ["lArr", { type: "Const", tex: "\\Leftarrow" }], ["hArr", { type: "Const", tex: "\\Leftrightarrow" }], ["curvArrLt", { type: "Const", tex: "\\curvearrowleft" }], ["curvArrRt", { type: "Const", tex: "\\curvearrowright" }], ["circArrLt", { type: "Const", tex: "\\circlearrowleft" }], ["circArrRt", { type: "Const", tex: "\\circlearrowright" }], ["sqrt", { type: "OperatorA", tex: "\\sqrt{ $1 }" }], ["root", { type: "OperatorOAB", tex: "\\sqrt[ $1 ]{ $2 }" }], ["frac", { type: "OperatorOAB", tex: "\\frac{ $1 }{ $2 }" }], ["/", { type: "OperatorAOB", tex: "\\frac{ $1 }{ $2 }" }], ["choose", { type: "OperatorAOB", tex: "{ $1 \\choose $2 }" }], ["_", { type: "OperatorSup", tex: "_{ $1 }" }], ["^", { type: "OperatorSup", tex: "^{ $1 }" }], ["stackrel", { type: "OperatorOAB", tex: "\\stackrel{ $1 }{ $2 }" }], ["overset", { type: "OperatorOAB", tex: "\\overset{ $1 }{ $2 }" }], ["underset", { type: "OperatorOAB", tex: "\\underset{ $1 }{ $2 }" }], ["hat", { type: "OperatorA", tex: "\\hat{ $1 }" }], ["\\`", { type: "OperatorA", tex: "\\`{ $1 }" }], ["widehat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["Hat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["widetilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["ol", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["overline", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["arc", { type: "OperatorA", tex: "\\stackrel{\\frown}{ $1 }" }], ["bar", { type: "OperatorA", tex: "\\bar{ $1 }" }], ["vec", { type: "OperatorA", tex: "\\overrightarrow{ $1 }" }], ["Vec", { type: "OperatorA", tex: "\\overrightarrow{ $1 }" }], ["Aec", { type: "OperatorA", tex: "\\overleftarrow{ $1 }" }], ["tilde", { type: "OperatorA", tex: "\\tilde{ $1 }" }], ["Tilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["dot", { type: "OperatorA", tex: "\\dot{ $1 }" }], ["ddot", { type: "OperatorA", tex: "\\ddot{ $1 }" }], ["ul", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underline", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underbrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["ubrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["overbrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["obrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["color", { type: "OperatorOAB", tex: "{ \\color{$1} $2 }", eatNext: true }], ["phantom", { type: "OperatorA", tex: "\\phantom{$1}" }], ["text", { type: "OperatorA", tex: "\\text{$1}", eatNext: true }], ["tex", { type: "OperatorA", tex: "$1", eatNext: true }], ["mbox", { type: "OperatorA", tex: "\\mbox{$1}" }], ["op", { type: "OperatorA", tex: "\\operatorname{ $1 }", eatNext: true }], ["cancel", { type: "OperatorA", tex: "\\cancel{ $1 }" }], ["bb", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["mathbf", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["sf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["mathsf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["bbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["mathbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["cc", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["mathcal", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["tt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["mathtt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["fr", { type: "OperatorA", tex: "\\mathfrak{ $1 }" }], ["bm", { type: "OperatorA", tex: "\\boldsymbol{ $1 }" }], ["rm", { type: "OperatorA", tex: "\\mathrm{ $1 }" }], ["scr", { type: "OperatorA", tex: "\\mathscr{ $1 }" }], ["limits", { type: "OperatorA", tex: "\\mathop{ $1 }\\limits" }], ["iint", { type: "Const", tex: "\\iint" }], ["iiint", { type: "Const", tex: "\\iiint" }], ["oiint", { type: "Const", tex: "\u222F" }], ["oiiint", { type: "Const", tex: "\u2230" }], ["laplace", { type: "Const", tex: "\\Delta" }], ["==", { type: "OperatorOptionalTwoParams", tex: "\\xlongequal[ $2 ]{ $1 }" }], ["-->", { type: "OperatorOptionalTwoParams", tex: "\\xrightarrow[ $2 ]{ $1 }" }], ["||", { type: "Paren", tex: "\\Vert" }], ["!||", { type: "Const", tex: "\u2226" }], ["S=", { type: "Const", tex: "\u224C" }], ["S~", { type: "Const", tex: "\u223D" }], ["!-=", { type: "Const", tex: "\\not\\equiv" }], ["!|", { type: "Const", tex: "\u2224" }], ["!", { type: "OperatorAO", tex: "{$1 !}" }], ["!!", { type: "OperatorAO", tex: "{$1 !!}" }], ["!sube", { type: "Const", tex: "\\not\\subseteq" }], ["!supe", { type: "Const", tex: "\\not\\supseteq" }], ["subne", { type: "Const", tex: "\\subsetneqq" }], ["supne", { type: "Const", tex: "\\supsetneqq" }], ["lhd", { type: "Const", tex: "\\lhd" }], ["rhd", { type: "Const", tex: "\\rhd" }], ["normal", { type: "Const", tex: "\\unlhd" }], ["rnormal", { type: "Const", tex: "\\unrhd" }], ["hline", { type: "Const", tex: "\\hline" }], ["--", { type: "Const", tex: "\\hline" }], ["(", { type: "LParen", tex: "(" }], [")", { type: "RParen", tex: ")" }], ["[", { type: "LParen", tex: "[" }], ["]", { type: "RParen", tex: "]" }], ["{", { type: "LParen", tex: "\\lbrace" }], ["}", { type: "RParen", tex: "\\rbrace" }], ["(:", { type: "LParen", tex: "\\langle" }], [":)", { type: "RParen", tex: "\\rangle" }], ["{:", { type: "LParen", tex: "." }], [":}", { type: "RParen", tex: "." }], ["|", { type: "Paren", tex: "|" }], ["mid", { type: "Const", tex: "\\mid" }], ["&", { type: "Align", tex: "&" }], ["&&", { type: "Align", tex: "&&" }], [",", { type: "Split", tex: "," }], [";", { type: "Split", tex: ";" }], ["-", { type: "OperatorMinus", tex: "{-$1 }" }], ["+", { type: "OperatorMinus", tex: "{+$1 }" }], ["part", { type: "OperatorPartial", tex: "\\partial" }], ["pp", { type: "OperatorPartial", tex: "\\partial" }], ["dd", { type: "OperatorPartial", tex: "\\mathrm{d}" }], ["tiny", { type: "OperatorA", tex: "{\\tiny $1 }" }], ["small", { type: "OperatorA", tex: "{\\small $1 }" }], ["large", { type: "OperatorA", tex: "{\\large $1 }" }], ["huge", { type: "OperatorA", tex: "{\\huge $1 }" }], ["o1", { type: "Const", tex: "\u2460" }], ["o2", { type: "Const", tex: "\u2461" }], ["o3", { type: "Const", tex: "\u2462" }], ["o4", { type: "Const", tex: "\u2463" }], ["o5", { type: "Const", tex: "\u2464" }], ["o6", { type: "Const", tex: "\u2465" }], ["ce", { type: "OperatorA", tex: "\\ce{$1}", eatNext: true }], ["Ksp", { type: "Const", tex: "K_{\\text{sp}}" }], ["Ka1", { type: "Const", tex: "K_{\\text{a}_1}" }], ["Ka2", { type: "Const", tex: "K_{\\text{a}_2}" }], ["Ka3", { type: "Const", tex: "K_{\\text{a}_3}" }], ["Ka", { type: "Const", tex: "K_{\\text{a}}" }], ["Kb", { type: "Const", tex: "K_{\\text{b}}" }], ["Kh1", { type: "Const", tex: "K_{\\text{h}_1}" }], ["Kh2", { type: "Const", tex: "K_{\\text{h}_2}" }], ["Kh3", { type: "Const", tex: "K_{\\text{h}_3}" }], ["Kh", { type: "Const", tex: "K_{\\text{h}}" }], ["Kw", { type: "Const", tex: "K_{\\text{w}}" }], ["pH", { type: "Const", tex: "\\mathrm{pH}" }], ["pOH", { type: "Const", tex: "\\mathrm{pOH}" }], ["cyc", { type: "Const", tex: "\\mathrm{cyc}" }]]);
function z() {
  return { type: "Root", body: [] };
}
function l(o) {
  if (typeof o > "u")
    return { type: "Const", value: "", tex: "" };
  if (typeof o == "string")
    return { type: "Const", value: o, tex: o };
  let e;
  return o.type === "Text" ? e = o.tex.replace(/^(\\quad)?(.+?)(\\quad)?$/, (t, n, p, s) => `${n || ""}\\text{${p}}${s || ""}`) : e = o.tex, { type: "Const", value: o.value, tex: e };
}
function k(o) {
  let e = [];
  return o && (Array.isArray(o) ? e = o : e.push(o)), { type: "Flat", body: e };
}
function $() {
  return { type: "Matrix", params: [], lparen: ".", rparen: ".", alignment: "c", dividerIndices: [] };
}
function c() {
  return { type: "ParamOne", tex: "", params: k() };
}
function g() {
  return { type: "ParamTwo", tex: "", params: [k(), k()] };
}
function w(o, e) {
  return { type: "Const", value: o.value, tex: `\\${e ? "left" : "right"}${o.tex}` };
}
function d(o) {
  return o.type !== "Flat" ? o : o.body.length === 1 ? o.body[0].type !== "Flat" ? o.body[0] : d(o.body[0]) : o;
}
function L(o, e) {
  let { closingIndex: t, semiIndex: n } = E(e, o);
  return t === -1 ? B(o, e) : n === -1 || n > t ? q(o, e, t) : M(o, e, t);
}
function v(o, e) {
  if (e + 1 >= o.length)
    return;
  let t = o[e], n = o[e + 1];
  t.type === "Const" && t.tex === "\\hline" && n.type === "Paren" && ([o[e], o[e + 1]] = [n, t]);
}
function M(o, e, t) {
  let n = o[e], p = $(), s = /* @__PURE__ */ new Set();
  p.lparen = `\\left${n.tex}`, e++;
  let a = [], r = null;
  v(o, e), n = o[e];
  let i = 0, y = e;
  for (; e < t; ) {
    if (n = o[e], n.type === "Split" && n.value === ",") {
      r ? (a.push(d(r)), r = null) : a.push(l()), ++e;
      continue;
    }
    if (n.type === "Split" && n.value === ";" || n.type === "Align" && n.tex === "\\\\") {
      r && (a.push(d(r)), r = null), p.params.push(a), a = [], e++, v(o, e);
      continue;
    }
    if (n.type === "Paren") {
      r && (a.push(d(r)), r = null), s.add(a.length), e++;
      continue;
    }
    for (r = k(); e < t && n.type !== "Split" && n.type !== "Paren" && n.type !== "Align"; ) {
      let T = u(o, e);
      e = T.current, r.body.push(T.node), n = o[e];
    }
    if (i++, i > t - y + 10)
      throw new Error(`Caught potential infinit loop in matrix parser! Cannot consume token \`${n.value}\` in ${i} loops (maybe greater than the token length)!`);
  }
  return r && (r = d(r), a.push(r), r = null), a.length > 0 && (p.params.push(a), a = []), p.dividerIndices = Array.from(s).sort((T, V) => T - V), n = o[e], e < o.length ? (e++, p.rparen = `\\right${n.tex}`, n.value === ":}" && p.lparen.endsWith("lbrace") && (p.alignment = "l")) : p.rparen = "\\right.", { node: p, current: e };
}
var O = class extends Error {
};
function q(o, e, t) {
  let n = o[e], p = k();
  if (p.body.push(w(n, true)), e = N(e + 1, t, o, p), e >= o.length)
    throw new O(`Read index out of range at line: ${n.pos.line}, ch: ${n.pos.ch}.`);
  return n = o[e], e++, p.body.push(w(n, false)), p.body[0].value === "{:" && p.body[p.body.length - 1].value === ":}" && (p.body[0].tex = "{", p.body[p.body.length - 1].tex = "}"), { node: p, current: e };
}
function B(o, e) {
  let t = o[e], n = k();
  return n.body.push({ type: "Const", value: t.value, tex: `\\left${t.tex}` }), e = N(e + 1, o.length, o, n), n.body.push({ type: "Const", value: ".", tex: "\\right." }), { node: n, current: e };
}
function E(o, e) {
  let t = -1, n = -1, p = [];
  for (let s = o + 1; s < e.length; s++) {
    if (e[s].type === "LParen") {
      p.push("");
      continue;
    }
    if (p.length === 0) {
      if (e[s].value === ";" ? t === -1 && (t = s) : e[s].type === "RParen" && n === -1 && (n = s), t !== -1 && n !== -1)
        break;
    } else
      e[s].type === "RParen" && p.pop();
  }
  return { closingIndex: n, semiIndex: t };
}
function K(o, e, t, n) {
  let p = -1, s = -1, a = [];
  for (let r = e; r < t; r++) {
    if (o[r].type === "LParen") {
      a.push("");
      continue;
    }
    if (a.length > 0 && o[r].type === "RParen") {
      a.pop();
      continue;
    }
    if (!(a.length > 0) && (o[r].type === "RParen" || (o[r].value === ";" ? p === -1 && (p = r) : o[r].value === n && s === -1 && (s = r), p !== -1 && s !== -1)))
      break;
  }
  return { semiIndex: p, barIndex: s };
}
function I(o, e) {
  let t = o[e], { semiIndex: n, barIndex: p } = K(o, e + 1, o.length, t.value);
  if (p === -1)
    return W(e, t);
  if (n === -1 || n > p) {
    let i = k();
    return e++, i.body.push(l(`\\left${t.tex}`)), e = N(e, p, o, i), i.body.push(l(`\\right${t.tex}`)), e = p + 1, { current: e, node: i };
  }
  let s = $();
  s.lparen = `\\left${t.tex}`, s.rparen = `\\right${t.tex}`, t = o[++e];
  let a = [], r = null;
  for (; e < p; ) {
    if (t.type === "Split") {
      switch (t.value) {
        case ",": {
          r ? (r.type === "Flat" && (r = d(r)), a.push(r), r = null) : a.push(l());
          break;
        }
        case ";": {
          r && (r.type === "Flat" && (r = d(r)), a.push(r), r = null), s.params.push(a), a = [];
          break;
        }
      }
      t = o[++e];
      continue;
    }
    for (r = k(), t = o[e]; e < p && t.type !== "Split"; ) {
      let i = u(o, e);
      e = i.current, r.body.push(i.node), t = o[e];
    }
  }
  return r && (r = d(r), a.push(r), r = null), a.length > 0 && (s.params.push(a), a = []), e = p + 1, { node: s, current: e };
}
function N(o, e, t, n) {
  for (; o < e; ) {
    let p = u(t, o);
    o = p.current, n.body.push(p.node);
  }
  return o;
}
function W(o, e) {
  return { current: o + 1, node: { type: "Const", value: e.value, tex: e.tex === "|" ? "|" : e.tex } };
}
function h(o) {
  let e = o.body[0], t = o.body[o.body.length - 1];
  return e.type === "Const" && t.type === "Const" && e.value === "(" && t.value === ")" && (o.body.pop(), o.body.shift()), o;
}
function D(o, e, t) {
  let n = o[e], p = l(), s = "", a = "", r = "";
  if (n.value === "^" || n.value === "_") {
    s = n.value === "^" ? "_" : "^", a = n.value, e++;
    let T = u(o, e, false);
    T.node.type === "Flat" && (T.node = h(T.node)), p = T.node, e = T.current;
  }
  let i = l();
  if (e < o.length && (n = o[e], n.value === s)) {
    r = n.value, e++;
    let T = u(o, e, false);
    T.node.type === "Flat" && (T.node = h(T.node)), i = T.node, e = T.current;
  }
  let y = g();
  return y.tex = t.tex, y.params[0] = a === "^" ? p : r === "^" ? i : l(), y.params[1] = a === "_" ? p : r === "_" ? i : l(), { node: y, current: e };
}
function j(o, e, t, n) {
  let p;
  o.type === "Flat" ? p = o : (p = k(), p.body.push(o));
  let s = c();
  s.tex = e.tex;
  let a = u(t, n, false);
  if (n = a.current, a.node.type === "Flat")
    a.node = h(a.node);
  else if (a.node.type === "Matrix") {
    let r = a.node;
    r.lparen.endsWith("(") && r.rparen.endsWith(")") && (r.lparen = "", r.rparen = "");
  }
  return s.params = a.node, s.params.type === "Flat" && (s.params = d(s.params)), p.body.push(s), o = d(p), { node: o, current: n };
}
function H(o, e) {
  let t = c();
  return t.params = o, t.tex = e.tex, o = t, o;
}
function G(o, e, t, n) {
  let p = g();
  o.type === "Flat" && (o = d(h(o))), p.tex = e.tex, p.params[0] = o;
  let s = u(t, n);
  return n = s.current, s.node.type === "Flat" && (s.node = d(h(s.node))), p.params[1] = s.node, o = p, { node: o, current: n };
}
function P(o, e, t) {
  let n = c(), p = o[e];
  n.tex = p.tex, e++;
  let s = u(o, e, t);
  return e = s.current, s.node.type === "Flat" && (s.node = d(h(s.node))), n.params = s.node, { node: n, current: e };
}
function Q(o, e) {
  let t = o[e];
  if (e > 0) {
    let a = o[e - 1];
    if (a.type !== "OperatorSup" && a.type !== "OperatorA" && a.type !== "OperatorOAB" && a.type !== "OperatorAOB")
      return { node: l(t.value), current: e + 1 };
  } else
    return { node: l(t.value), current: e + 1 };
  if (e++, e >= o.length)
    return { node: l(t.value), current: e };
  if (o[e].type === "RParen")
    return { node: l(t.value), current: e };
  let p = u(o, e, true);
  e = p.current;
  let s = c();
  return s.tex = t.tex, s.params = p.node, { node: s, current: e };
}
function U(o, e, t) {
  let n = k();
  return n.body.push(l(o)), e && n.body.push(e), n.body.push(t), n;
}
function Z(o, e) {
  return k(o.body.flatMap((t) => [l(e), t]));
}
function X(o, e) {
  let t = g(), n = o[e];
  t.tex = "\\frac{ $1 }{ $2 }";
  let p = n.tex, s = null;
  if (e++, e >= o.length)
    return { node: t, current: e };
  if (n = o[e], n.type === "OperatorSup") {
    let i = P(o, e, false);
    e = i.current, s = i.node;
  }
  let a = u(o, e, true);
  if (e = a.current, a.node.type === "Flat" && (a.node = h(a.node)), t.params[0] = U(p, s, a.node), e >= o.length)
    return { node: t, current: e };
  let r = u(o, e);
  return e = r.current, r.node.type === "Flat" ? (r.node = h(r.node), r.node = Z(r.node, p)) : (r.node = k(r.node), r.node.body.unshift(l(p)), s && r.node.body.push(s)), t.params[1] = r.node, { node: t, current: e };
}
function u(o, e, t = true) {
  if (e >= o.length)
    return { node: l(), current: e };
  let n = o[e], p;
  switch (n.type) {
    case "Const":
    case "Text":
    case "NumberLiteral":
    case "StringLiteral": {
      e++, p = l(n);
      break;
    }
    case "LParen": {
      ({ node: p, current: e } = L(o, e));
      break;
    }
    case "Paren": {
      ({ node: p, current: e } = I(o, e));
      break;
    }
    case "OperatorSup":
    case "OperatorA": {
      ({ node: p, current: e } = P(o, e, false));
      break;
    }
    case "OperatorMinus": {
      ({ node: p, current: e } = Q(o, e));
      break;
    }
    case "OperatorOAB": {
      p = g(), p.tex = n.tex, e++;
      let s = u(o, e);
      e = s.current, s.node.type === "Flat" && (s.node = d(h(s.node))), p.params[0] = s.node;
      let a = u(o, e);
      e = a.current, a.node.type === "Flat" && (a.node = d(h(a.node))), p.params[1] = a.node;
      break;
    }
    case "OperatorOptionalTwoParams": {
      if (e++, e >= o.length) {
        p = l(`${n.tex.replace(/[\{\[] \$\d+ [\}\]]/g, "")}{}`);
        break;
      }
      ({ node: p, current: e } = D(o, e, n));
      break;
    }
    case "OperatorPartial": {
      ({ node: p, current: e } = X(o, e));
      break;
    }
    case "Split":
    case "Align": {
      e++, p = l(n);
      break;
    }
    case "RParen": {
      e++, p = l(n);
      break;
    }
    default:
      throw new Error(`Unmatched token \`${n.value}\` at line: ${n.pos.line}, ch: ${n.pos.ch}.`);
  }
  if (e < o.length && t) {
    let s = true;
    for (; s && e < o.length; ) {
      let a = o[e];
      switch (a.type) {
        case "OperatorAOB": {
          ({ node: p, current: e } = G(p, a, o, e + 1));
          break;
        }
        case "OperatorAO": {
          p = H(p, a), e++;
          break;
        }
        case "OperatorSup": {
          ({ node: p, current: e } = j(p, a, o, e + 1));
          break;
        }
        default:
          s = false;
      }
    }
  }
  return { node: p, current: e };
}
function R(o) {
  let e = z(), t = 0;
  for (; t < o.length; ) {
    let n = u(o, t);
    t = n.current, e.body.push(n.node);
  }
  return e;
}
function Y(o) {
  let e = o.dividerIndices, t = "\\begin{array}", n = o.alignment;
  if (e.length) {
    let p = e[e.length - 1];
    for (let a = e.length - 1; a >= 1; a--)
      e[a] -= e[a - 1];
    t += "{";
    for (let a = 0; a < e.length; a++)
      t += `${n.repeat(e[a])}|`;
    let s = Math.max(...o.params.map((a) => a.length));
    t += `${n.repeat(s - p)}}`;
  } else {
    let p = Math.max(...o.params.map((s) => s.length));
    t += `{${n.repeat(p)}}`;
  }
  return [t, "\\end{array}"];
}
function C(o) {
  switch (o.type) {
    case "Const":
      return o.tex;
    case "Root": {
      let e = o.body.map(C).join(" ");
      return o.body.find((t) => t.type === "Const" && (t.value === "&" || t.tex === "\\\\")) && (e = `\\begin{gather*}${e}\\end{gather*}`), e;
    }
    case "Flat":
      return o.body.map(C).join(" ");
    case "Matrix": {
      let [e, t] = Y(o);
      return [o.lparen, e, o.params.map((n) => n.map(C).join(" & ")).join(" \\\\ "), t, o.rparen].join(" ");
    }
    case "ParamOne":
      return o.tex.replace("$1", C(o.params));
    case "ParamTwo":
      return o.tex.replace("$1", C(o.params[0])).replace("$2", C(o.params[1]));
  }
}
var _ = /[0-9]/;
var J = /\S/;
var ee = (o) => {
  let { value: e = "", current: t, pos: n } = o;
  return { value: e, isKeyWord: false, current: t, pos: n, tex: e, type: "Const" };
};
var A = class {
  constructor(e) {
    __publicField(this, "_root");
    __publicField(this, "_char_to_index", /* @__PURE__ */ new Map());
    __publicField(this, "_n");
    if (e.length === 0)
      throw new Error("Cannot create Trie since the length of nodes is 0");
    e.forEach((n) => {
      if (n.length !== 1)
        throw new Error(`Value \`${n}\` is invalid, the length of char must be 1`);
    });
    let t = Array.from(new Set(e));
    this._n = t.length, this._root = new b(this._n), t.forEach((n, p) => {
      this._char_to_index.set(n, p);
    });
  }
  c2i(e) {
    return this._char_to_index.get(e);
  }
  insert(e) {
    if (e.length === 0)
      return;
    let t = this._root;
    [...e].forEach((n, p) => {
      let s = this.c2i(n);
      if (typeof s > "u")
        throw new Error(`key \`${n}\` not in key set`);
      t._nextNode[s] === null && (t._nextNode[s] = new b(this._n)), t = t._nextNode[s], p === e.length - 1 && (t._end = true);
    });
  }
  search(e) {
    if (!this._root._nextNode.find((p) => p !== null) || e.length === 0)
      return false;
    let t = this._root, n = 0;
    for (; n < e.length; n++) {
      let p = e[n], s = this.c2i(p);
      if (typeof s > "u")
        throw new Error(`key \`${p}\` not in key set`);
      if (t._nextNode[s] === null)
        return false;
      t = t._nextNode[s];
    }
    return n === e.length;
  }
  tryParsing(e, t = 0, n = { line: 1, ch: 0 }) {
    let p = "", s = this._root, a = false, r = t;
    for (; r < e.length; r++) {
      let y = e[r], T = this.c2i(y);
      if (typeof T > "u" || s._nextNode[T] === null)
        break;
      p += y, s = s._nextNode[T], a = s._end;
    }
    let i = a ? f.get(p) : { tex: p, type: "StringLiteral" };
    return { value: p, isKeyWord: a, current: r, ...i, pos: n };
  }
  tryParsingNumber(e, t, n) {
    let p = e[t], s = "";
    for (; _.test(p) && t < e.length; )
      s += p, p = e[++t];
    for (p === "." && (s += p, p = e[++t]); _.test(p) && t < e.length; )
      s += p, p = e[++t];
    return { value: s, isKeyWord: false, current: t, pos: n, tex: s, type: "NumberLiteral" };
  }
  tryParsingString(e, t, n) {
    let p = e[t], s = "";
    for (; J.test(p) && t < e.length; ) {
      let a = this.c2i(p);
      if (typeof a < "u" && this._root._nextNode[a] !== null)
        break;
      s += p, p = e[++t];
    }
    return { value: s, isKeyWord: false, current: t, pos: n, tex: s, type: "StringLiteral" };
  }
  tryParsingNewLines(e, t, n) {
    let p = e[t], s = "";
    for (; /\n/.test(p) && t < e.length; )
      s += p, p = e[++t], n.line++, n.ch = 0;
    return s.length >= 2 ? { value: s, isKeyWord: true, current: t, pos: n, tex: "\\\\", type: "Align" } : { value: "", isKeyWord: false, current: t, pos: n, tex: "", type: "None" };
  }
  getPlainTextInDoubleQuote(e, t, n) {
    let p = "", s = e[t];
    if (s === '"') {
      for (s = e[++t]; s !== '"' && t < e.length; )
        p += s, s = e[++t];
      if (s === '"')
        return t++, { current: t, value: p, pos: n };
    }
    return { value: p, current: t, pos: n };
  }
  tryParsingText(e, t, n) {
    let { value: p, current: s } = this.getPlainTextInDoubleQuote(e, t, n);
    return { value: p, isKeyWord: false, current: s, pos: n, tex: p, type: "Text" };
  }
  skipSpaces(e, t) {
    for (; t < e.length; ) {
      let n = e[t];
      if (!/\s/.test(n))
        break;
      t++;
    }
    return t;
  }
  eatNext(e, t, n) {
    t = this.skipSpaces(e, t);
    let p = ee({ current: t, pos: n });
    if (t >= e.length)
      return p;
    let s = e[t], a = "";
    switch (s) {
      case '"': {
        for (s = e[++t]; t < e.length && s !== '"'; )
          a += s, s = e[++t];
        t++;
        break;
      }
      case "(": {
        for (s = e[++t]; t < e.length && s !== ")"; )
          a += s, s = e[++t];
        t++;
        break;
      }
      default: {
        for (; t < e.length && /\S/.test(s); )
          s = e[t++], a += s;
        break;
      }
    }
    return p.tex = p.value = a, p.current = t, p;
  }
  tryParsingAll(e) {
    let t = 0, n = [], p = 0, s = [...e], a = 1, r = 0;
    for (; t < s.length; ) {
      {
        let y = this.tryParsingNewLines(s, t, { line: a, ch: r });
        if (a = y.pos.line, r = y.pos.ch, t = y.current, y.value !== "") {
          n.push(y);
          continue;
        }
      }
      if (/\s/.test(s[t])) {
        t++, r++;
        continue;
      }
      let i = this.tryParsing(s, t, { line: a, ch: r });
      if (r += i.current - t, t = i.current, i.value !== "") {
        if (n.push(i), i.eatNext) {
          let y = this.eatNext(s, t, { line: a, ch: r });
          r += y.current - t, t = y.current, n.push(y);
        }
        continue;
      }
      {
        let y = this.tryParsingNumber(s, t, { line: a, ch: r });
        if (r += y.current - t, t = y.current, y.value !== "") {
          n.push(y);
          continue;
        }
      }
      {
        let y = this.tryParsingText(s, t, { line: a, ch: r });
        if (r += y.current - t, t = y.current, y.value !== "") {
          n.push(y);
          continue;
        }
      }
      {
        let y = this.tryParsingString(s, t, { line: a, ch: r });
        if (r += y.current - t, t = y.current, y.value !== "") {
          n.push(y);
          continue;
        }
      }
      if (p++, p > s.length * 2)
        throw new Error("Oops! There may be an infinity loop!");
    }
    return n;
  }
};
var b = class {
  constructor(e) {
    __publicField(this, "_nextNode", []);
    __publicField(this, "_end", false);
    this._nextNode = Array.from({ length: e }, () => null);
  }
};
function S(o = {}) {
  let e = /* @__PURE__ */ new Set([]);
  o.symbols && (Array.isArray(o.symbols) ? o.symbols.forEach(([p, s]) => {
    if (p.length === 0)
      throw new Error(`Cannot insert empty token! Token value: ${s}`);
    f.set(p, s);
  }) : Object.entries(o.symbols).forEach(([p, s]) => {
    if (p.length === 0)
      throw new Error(`Cannot insert empty token! Token value: ${s}`);
    f.set(p, s);
  }));
  for (let p of f.keys())
    [...p].forEach((s) => e.add(s));
  let t = Array.from(e);
  t.push(" ");
  let n = new A(t);
  for (let p of f.keys())
    n.insert(p);
  return n;
}
function te(o) {
  var _a;
  let e = { display: true, symbols: { dx: { type: "Const", tex: "{\\text{d}x}" }, dy: { type: "Const", tex: "{\\text{d}y}" }, dz: { type: "Const", tex: "{\\text{d}z}" }, dt: { type: "Const", tex: "{\\text{d}t}" }, "#": { type: "Const", tex: "\\displaystyle" }, atop: { type: "OperatorAOB", tex: "{ $1 \\atop $2 }" } }, replaceBeforeTokenizing: [[/([^\n])\n(?!\n)/g, "$1\n\n"],[/&#(x?[0-9a-fA-F]+);/g, (t, n) => String.fromCodePoint(n[0] === "x" ? `0${n}` : n)]] };
  return typeof (o == null ? void 0 : o.display) < "u" && (e.display = o.display), (o == null ? void 0 : o.symbols) && (Array.isArray(o.symbols) ? o.symbols.forEach(([t, n]) => {
    e.symbols[t] = n;
  }) : e.symbols = { ...e.symbols, ...o.symbols }), ((_a = o == null ? void 0 : o.replaceBeforeTokenizing) == null ? void 0 : _a.length) && e.replaceBeforeTokenizing.push(...o.replaceBeforeTokenizing), e;
}
var F = class {
  constructor(e) {
    __publicField(this, "trie");
    __publicField(this, "display");
    __publicField(this, "replaceLaws");
    let { display: t, symbols: n, replaceBeforeTokenizing: p } = te(e);
    this.trie = S({ symbols: n }), this.display = t, this.replaceLaws = p;
  }
  toTex(e, t) {
    try {
      e = this.replaceLaws.reduce((p, s) => p.replaceAll(s[0], s[1]), e);
      let n = C(R(this.trie.tryParsingAll(e)));
      return typeof (t == null ? void 0 : t.display) > "u" ? this.display && (n = `\\displaystyle{ ${n} }`) : t.display && (n = `\\displaystyle{ ${n} }`), n;
    } catch (n) {
      return `\\text{${String(n)}}`;
    }
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var AsciiMathSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for asciimath" });
    new import_obsidian.Setting(containerEl).setName("Code block prefix aliases").setDesc("Seperate different aliases with comma.").addText((text) => text.setPlaceholder("asciimath, am").setValue(this.plugin.settings.blockPrefix.join(", ")).onChange((0, import_obsidian.debounce)((value) => {
      this.plugin.settings.blockPrefix = value.split(",").map((s) => s.trim()).filter(Boolean);
    }, 1e3)));
    new import_obsidian.Setting(containerEl).setName("Replace math blocks").setDesc("Enable this if you want to use AsciiMath but keep using default math blocks (dollar-sign blocks). This will not affect your previous notes that are written in LaTeX because the plugin will check which syntax to use before drawing the math.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.replaceMathBlock).onChange((v2) => {
        this.plugin.settings.replaceMathBlock = v2;
        this.plugin.setupMathBlockRendering();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Custom symbols").setDesc("Transforms custom symbols into LaTeX symbols. One row for each rule.").addTextArea((text) => {
      const el = text.setPlaceholder("symbol1, \\LaTeXSymbol1\nsymbol2, \\LaTeXSymbol2\n...").setValue(this.plugin.settings.customSymbols.map((r) => r.join(", ")).join("\n")).onChange((0, import_obsidian.debounce)((value) => {
        this.plugin.settings.customSymbols = value.split("\n").map((r) => r.split(",").map((s) => s.trim()).filter(Boolean)).filter((l2) => l2.length);
      }, 1e3));
      el.inputEl.addClass("__asciimath_settings_custom-symbols");
    });
    new import_obsidian.Setting(containerEl).setName("Don't forget to save and reload settings \u2192").addButton((btn) => btn.setButtonText("Save").onClick(async () => {
      const valid = validateSettings(this.plugin.settings);
      if (!valid.isValid) {
        new import_obsidian.Notice(valid.message);
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      this.plugin.settings.blockPrefix.forEach((prefix) => {
        if (!this.plugin.existPrefixes.includes(prefix))
          this.plugin.registerAsciiMathCodeBlock(prefix);
      });
      this.plugin.AM = new F({
        symbols: this.plugin.calcSymbols()
      });
      new import_obsidian.Notice("Asciimath settings reloaded successfully!");
    }));
  }
};
function validateSettings(settings) {
  if (settings.blockPrefix.length < 1) {
    return {
      isValid: false,
      message: "You should add at least 1 block prefix!"
    };
  }
  const { customSymbols } = settings;
  if (customSymbols.find((pair) => pair.length !== 2)) {
    return {
      isValid: false,
      message: "Custom rule should be two string split with a comma!"
    };
  }
  return {
    isValid: true,
    message: "OK"
  };
}

// src/utils.ts
function isLatexCode(code) {
  const latexRegex = /\\([A-Za-z0-9]){2,}/gm;
  const simpleLatexSupSubRegex = /[\^_]\{\s*[a-zA-Z0-9 ]+\s*\}/g;
  const texEmbedRegex = /tex".*"/;
  const hasTrueLatex = latexRegex.test(code);
  const hasSimpleLatexSupSub = simpleLatexSupSubRegex.test(code);
  const hasTexEmbed = texEmbedRegex.test(code);
  return (hasTrueLatex || hasSimpleLatexSupSub && !hasTrueLatex) && !hasTexEmbed;
}
function toTex(am, content, displayMode) {
  const tex = am.toTex(content, { display: displayMode });
  return tex.replace(/(\{|\})(\1+)/g, (...args) => Array(args[2].length + 1).fill(args[1]).join(" "));
}

// src/symbol-search/modal.ts
var import_obsidian2 = require("obsidian");

// src/symbol-search/symbols.json
var symbols_default = [
  { am: "alpha", tex: "\\alpha" },
  { am: "beta", tex: "\\beta" },
  { am: "gamma", tex: "\\gamma" },
  { am: "Gamma", tex: "\\Gamma" },
  { am: "delta", tex: "\\delta" },
  { am: "Delta", tex: "\\Delta" },
  { am: "epsi", tex: "\\varepsilon" },
  { am: "epsilon", tex: "\\epsilon" },
  { am: "varepsilon", tex: "\\varepsilon" },
  { am: "zeta", tex: "\\zeta" },
  { am: "eta", tex: "\\eta" },
  { am: "theta", tex: "\\theta" },
  { am: "Theta", tex: "\\Theta" },
  { am: "vartheta", tex: "\\vartheta" },
  { am: "iota", tex: "\\iota" },
  { am: "kappa", tex: "\\kappa" },
  { am: "lambda", tex: "\\lambda" },
  { am: "Lambda", tex: "\\Lambda" },
  { am: "mu", tex: "\\mu" },
  { am: "nu", tex: "\\nu" },
  { am: "xi", tex: "\\xi" },
  { am: "Xi", tex: "\\Xi" },
  { am: "pi", tex: "\\pi" },
  { am: "Pi", tex: "\\Pi" },
  { am: "rho", tex: "\\rho" },
  { am: "sigma", tex: "\\sigma" },
  { am: "Sigma", tex: "\\Sigma" },
  { am: "tau", tex: "\\tau" },
  { am: "upsilon", tex: "\\upsilon" },
  { am: "phi", tex: "\\phi" },
  { am: "varphi", tex: "\\varphi" },
  { am: "varPhi", tex: "\\varPhi" },
  { am: "Phi", tex: "\\Phi" },
  { am: "chi", tex: "\\chi" },
  { am: "psi", tex: "\\psi" },
  { am: "Psi", tex: "\\Psi" },
  { am: "omega", tex: "\\omega" },
  { am: "Omega", tex: "\\Omega" },
  { am: "***", tex: "\\star" },
  { am: "star", tex: "\\star" },
  { am: "**", tex: "\\ast" },
  { am: "ast", tex: "\\ast" },
  { am: "*", tex: "\\cdot" },
  { am: "cdot", tex: "\\cdot" },
  { am: "//", tex: "{/}", rendered: "a//b" },
  { am: "\\\\", tex: "\\backslash" },
  { am: "setminus", tex: "\\setminus" },
  { am: "xx", tex: "\\times" },
  { am: "|><", tex: "\\ltimes" },
  { am: "><|", tex: "\\rtimes" },
  { am: "|><|", tex: "\\bowtie" },
  { am: "-:", tex: "\\div" },
  { am: "@", tex: "\\circ" },
  { am: "o+", tex: "\\oplus" },
  { am: "ox", tex: "\\otimes" },
  { am: "o.", tex: "\\odot" },
  { am: "sum", tex: "\\sum" },
  { am: "prod", tex: "\\prod" },
  { am: "^^", tex: "\\wedge" },
  { am: "^^^", tex: "\\bigwedge" },
  { am: "vv", tex: "\\vee" },
  { am: "vvv", tex: "\\bigvee" },
  { am: "nn", tex: "\\cap" },
  { am: "nnn", tex: "\\bigcap" },
  { am: "uu", tex: "\\cup" },
  { am: "uuu", tex: "\\bigcup" },
  { am: "!=", tex: "\\ne" },
  { am: "lt", tex: "<" },
  { am: "<=", tex: "\\leqslant" },
  { am: "le", tex: "\\le" },
  { am: "gt", tex: ">" },
  { am: ">=", tex: "\\geqslant" },
  { am: "ge", tex: "\\ge" },
  { am: "-<", tex: "\\prec" },
  { am: ">-", tex: "\\succ" },
  { am: "-<=", tex: "\\preceq" },
  { am: ">-=", tex: "\\succeq" },
  { am: "in", tex: "\\in" },
  { am: "!in", tex: "\\notin" },
  { am: "sub", tex: "\\subset" },
  { am: "sup", tex: "\\supset" },
  { am: "sube", tex: "\\subseteq" },
  { am: "supe", tex: "\\supseteq" },
  { am: "-=", tex: "\\equiv" },
  { am: "~=", tex: "\\cong" },
  { am: "~", tex: "\\sim" },
  { am: "~~", tex: "\\approx" },
  { am: "\\#", tex: "\\#" },
  { am: "\\&", tex: "\\&" },
  { am: "\\@", tex: "@" },
  { am: "\\%", tex: "\\%" },
  { am: "%", tex: "\\%" },
  { am: "\\$", tex: "\\$" },
  { am: "\\,", tex: "\\," },
  { am: "\\;", tex: "\\;" },
  { am: "\\:", tex: "\\:" },
  { am: "\\!", tex: "\\!" },
  { am: "enspace", tex: "a\\enspace b" },
  {
    am: "hspace",
    tex: "\\hspace{$1}",
    rendered: "a\\hspace{12pt}b",
    placeholder: "($1)",
    fill: ["12pt"]
  },
  { am: "prop", tex: "\\propto" },
  { am: "comp", tex: "\\complement" },
  { am: "complement", tex: "\\complement" },
  { am: "if", tex: "\\text{if}\\quad", rendered: "\\text{if}" },
  {
    am: "otherwise",
    tex: "\\text{otherwise}\\quad",
    rendered: "\\text{otherwise}"
  },
  { am: "and", tex: " and ", rendered: "\\text{ and }" },
  { am: "or", tex: " or ", rendered: "\\text{ or }" },
  { am: "not", tex: "\\neg" },
  { am: "=>", tex: "\\implies" },
  { am: "~>", tex: "\\rightsquigarrow" },
  { am: "-/->", tex: "\\nrightarrow" },
  { am: "<-/-", tex: "\\nleftarrow" },
  { am: "<-/->", tex: "\\nleftrightarrow" },
  { am: "<=>", tex: "\\iff" },
  { am: "iff", tex: "\\iff" },
  { am: "AA", tex: "\\forall" },
  { am: "EE", tex: "\\exists" },
  { am: "_|_", tex: "\\bot" },
  { am: "TT", tex: "\\top" },
  { am: "|--", tex: "\\vdash" },
  { am: "|==", tex: "\\models" },
  { am: "int", tex: "\\int" },
  { am: "oint", tex: "\\oint" },
  { am: "del", tex: "\\partial" },
  { am: "grad", tex: "\\nabla" },
  { am: "+-", tex: "\\pm" },
  { am: "-+", tex: "\\mp" },
  { am: "O/", tex: "\\varnothing" },
  { am: "oo", tex: "\\infty" },
  { am: "aleph", tex: "\\aleph" },
  { am: "...", tex: "\\ldots" },
  { am: ":.", tex: "\\therefore" },
  { am: ":'", tex: "\\because" },
  { am: "/_", tex: "\\angle" },
  { am: "/_\\", tex: "\\triangle" },
  { am: "quad", tex: "\\quad" },
  { am: "qquad", tex: "\\qquad" },
  { am: "cdots", tex: "\\cdots" },
  { am: "vdots", tex: "\\vdots" },
  { am: "ddots", tex: "\\ddots" },
  { am: "diamond", tex: "\\diamond" },
  { am: "Lap", tex: "\\mathscr{L}" },
  { am: "square", tex: "\\square" },
  { am: "|__", tex: "\\lfloor" },
  { am: "__|", tex: "\\rfloor" },
  { am: "|~", tex: "\\lceil" },
  { am: "~|", tex: "\\rceil" },
  { am: "CC", tex: "\\mathbb{C}" },
  { am: "NN", tex: "\\mathbb{N}" },
  { am: "QQ", tex: "\\mathbb{Q}" },
  { am: "RR", tex: "\\mathbb{R}" },
  { am: "ZZ", tex: "\\mathbb{Z}" },
  { am: "'", tex: "^{\\prime}" },
  { am: "''", tex: "^{\\prime\\prime}" },
  { am: "'''", tex: "^{\\prime\\prime\\prime}" },
  {
    am: "lim",
    tex: "\\lim_{$2} $1",
    placeholder: "_($2) $1",
    fill: ["f(x)", "x\\to 0"]
  },
  { am: "sin", tex: "\\sin" },
  { am: "cos", tex: "\\cos" },
  { am: "tan", tex: "\\tan" },
  { am: "sinh", tex: "\\sinh" },
  { am: "cosh", tex: "\\cosh" },
  { am: "tanh", tex: "\\tanh" },
  { am: "cot", tex: "\\cot" },
  { am: "sec", tex: "\\sec" },
  { am: "csc", tex: "\\csc" },
  { am: "arcsin", tex: "\\arcsin" },
  { am: "arccos", tex: "\\arccos" },
  { am: "arctan", tex: "\\arctan" },
  { am: "coth", tex: "\\coth" },
  { am: "sech", tex: "\\operatorname{sech}" },
  { am: "csch", tex: "\\operatorname{csch}" },
  { am: "exp", tex: "\\exp" },
  { am: "log", tex: "\\log" },
  { am: "ln", tex: "\\ln" },
  { am: "det", tex: "\\det" },
  { am: "dim", tex: "\\dim" },
  { am: "gcd", tex: "\\gcd" },
  { am: "lcm", tex: "\\operatorname{lcm}" },
  { am: "min", tex: "\\min" },
  { am: "max", tex: "\\max" },
  { am: "Sup", tex: "\\sup" },
  { am: "inf", tex: "\\inf" },
  { am: "mod", tex: "\\operatorname{mod}" },
  { am: "sgn", tex: "\\operatorname{sgn}" },
  {
    am: "abs",
    tex: "\\left| $1 \\right|",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "norm",
    tex: "\\left\\| $1 \\right\\|",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "floor",
    tex: "\\left\\lfloor $1 \\right\\rfloor",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "ceil",
    tex: "\\left\\lceil $1 \\right\\rceil",
    placeholder: "($1)",
    fill: ["a"]
  },
  { am: "uarr", tex: "\\uparrow" },
  { am: "uparrow", tex: "\\uparrow" },
  { am: "darr", tex: "\\downarrow" },
  { am: "downarrow", tex: "\\downarrow" },
  { am: "rarr", tex: "\\rightarrow" },
  { am: "rightarrow", tex: "\\rightarrow" },
  { am: "to", tex: "\\to" },
  { am: "->", tex: "\\to" },
  { am: "<-", tex: "\\gets" },
  { am: ">->", tex: "\\rightarrowtail" },
  { am: "->>", tex: "\\twoheadrightarrow" },
  { am: ">->>", tex: "\u2916" },
  { am: "|->", tex: "\\mapsto" },
  { am: "larr", tex: "\\leftarrow" },
  { am: "leftarrow", tex: "\\leftarrow" },
  { am: "harr", tex: "\\leftrightarrow" },
  { am: "rArr", tex: "\\Rightarrow" },
  { am: "lArr", tex: "\\Leftarrow" },
  { am: "hArr", tex: "\\Leftrightarrow" },
  { am: "curvArrLt", tex: "\\curvearrowleft" },
  { am: "curvArrRt", tex: "\\curvearrowright" },
  { am: "circArrLt", tex: "\\circlearrowleft" },
  { am: "circArrRt", tex: "\\circlearrowright" },
  { am: "sqrt", tex: "\\sqrt{ $1 }", placeholder: "($1)", fill: ["a"] },
  {
    am: "root",
    tex: "\\sqrt[ $1 ]{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  {
    am: "frac",
    tex: "\\frac{ $1 }{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  {
    am: "/",
    tex: "\\frac{ $1 }{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  { am: "choose", tex: "{ a \\choose b }" },
  {
    am: "_",
    tex: "_{ $1 }",
    rendered: "x_{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "^",
    tex: "^{ $1 }",
    rendered: "x^{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "stackrel",
    tex: "\\stackrel{ $1 }{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  {
    am: "overset",
    tex: "\\overset{ $1 }{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  {
    am: "underset",
    tex: "\\underset{ $1 }{ $2 }",
    placeholder: "($1)($2)",
    fill: ["a", "b"]
  },
  { am: "hat", tex: "\\hat{ $1 }", placeholder: "($1)", fill: ["a"] },
  {
    am: "Hat",
    tex: "\\widehat{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "ol",
    tex: "\\overline{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "overline",
    tex: "\\overline{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "arc",
    tex: "\\stackrel{\\frown}{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  { am: "bar", tex: "\\bar{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "vec", tex: "\\vec{ $1 }", placeholder: "($1)", fill: ["a"] },
  {
    am: "Vec",
    tex: "\\overrightarrow{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "tilde",
    tex: "\\tilde{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "Tilde",
    tex: "\\widetilde{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  { am: "dot", tex: "\\dot{ $1 }", placeholder: "($1)", fill: ["a"] },
  { am: "ddot", tex: "\\ddot{ $1 }", placeholder: "($1)", fill: ["a"] },
  {
    am: "ul",
    tex: "\\underline{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "underline",
    tex: "\\underline{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "underbrace",
    tex: "\\underbrace{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "ubrace",
    tex: "\\underbrace{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "overbrace",
    tex: "\\overbrace{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "obrace",
    tex: "\\overbrace{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "color",
    tex: "{ \\color{$2} $1 }",
    placeholder: "($2)($1)",
    fill: ["b", "red"]
  },
  {
    am: "phantom",
    tex: "\\phantom{a}",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "text",
    tex: "\\text{$1}",
    rendered: "",
    placeholder: '"$1"',
    fill: ["a"]
  },
  { am: "tex", tex: "$1", placeholder: '"$1"', fill: ["a"] },
  { am: "mbox", tex: "\\mbox{a}", placeholder: "($1)", fill: ["a"] },
  {
    am: "op",
    tex: "\\operatorname{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  {
    am: "cancel",
    tex: "\\cancel{ $1 }",
    placeholder: "($1)",
    fill: ["a"]
  },
  { am: "bb", tex: "\\mathbf{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "sf", tex: "\\mathsf{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "bbb", tex: "\\mathbb{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "cc", tex: "\\mathcal{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "tt", tex: "\\mathtt{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "fr", tex: "\\mathfrak{$1}", placeholder: "($1)", fill: ["A"] },
  {
    am: "bm",
    tex: "\\boldsymbol{$1}",
    placeholder: "($1)",
    fill: ["A"]
  },
  { am: "rm", tex: "\\mathrm{$1}", placeholder: "($1)", fill: ["A"] },
  { am: "scr", tex: "\\mathscr{$1}", placeholder: "($1)", fill: ["A"] },
  {
    am: "limits",
    tex: "\\mathop{ $1 }\\limits",
    rendered: "\\mathop{ $1 }\\limits_{k=1}^n",
    placeholder: "($1)_($2)^($3)",
    fill: ["a", "k=1", "n"]
  },
  { am: "iint", tex: "\\iint" },
  { am: "iiint", tex: "\\iiint" },
  { am: "oiint", tex: "\u222F" },
  { am: "oiiint", tex: "\u2230" },
  { am: "laplace", tex: "\\Delta" },
  {
    am: "==",
    tex: "\\xlongequal[ $2 ]{ $1 }",
    placeholder: "^($1)_($2)",
    fill: ["a", "b"]
  },
  {
    am: "-->",
    tex: "\\xrightarrow[ $2 ]{ $1 }",
    placeholder: "^($1)_($2)",
    fill: ["a", "b"]
  },
  { am: "||", tex: "\\Vert", rendered: "\\Vert" },
  { am: "!||", tex: "\u2226" },
  { am: "S=", tex: "\u224C" },
  { am: "S~", tex: "\u223D" },
  { am: "!-=", tex: "\\not\\equiv" },
  { am: "!|", tex: "\u2224" },
  { am: "!", tex: "{a !}" },
  { am: "!!", tex: "{a !!}" },
  { am: "!sube", tex: "\\not\\subseteq" },
  { am: "!supe", tex: "\\not\\supseteq" },
  { am: "subne", tex: "\\subsetneqq" },
  { am: "supne", tex: "\\supsetneqq" },
  { am: "lhd", tex: "\\lhd" },
  { am: "rhd", tex: "\\rhd" },
  { am: "normal", tex: "\\unlhd" },
  { am: "rnormal", tex: "\\unrhd" },
  { am: "(", tex: "(" },
  { am: ")", tex: ")" },
  { am: "[", tex: "[" },
  { am: "]", tex: "]" },
  { am: "{", tex: "\\lbrace" },
  { am: "}", tex: "\\rbrace" },
  { am: "(:", tex: "\\langle" },
  { am: ":)", tex: "\\rangle" },
  { am: "{:", tex: "{", rendered: "" },
  { am: ":}", tex: "}", rendered: "" },
  { am: "|", tex: "|" },
  { am: "&", tex: "&" },
  { am: "&&", tex: "&&" },
  { am: ",", tex: "," },
  { am: ";", tex: ";" },
  {
    am: "pp",
    tex: "\\frac{ \\partial ^ $3 { $1 } }{ \\partial $2 ^ $3 }",
    placeholder: "^$3 ($1)($2)",
    fill: ["f", "x", "n"]
  },
  {
    am: "dd",
    tex: "\\frac{ \\mathrm{d} ^ $3 { $1 } }{ \\mathrm{d} $2 ^ $3 }",
    placeholder: "^$3 ($1)($2)",
    fill: ["f", "x", "n"]
  },
  {
    am: "tiny",
    tex: "{\\tiny $1 }",
    placeholder: "($1)",
    fill: ["\\text{text}"]
  },
  {
    am: "small",
    tex: "{\\small $1 }",
    placeholder: "($1)",
    fill: ["\\text{text}"]
  },
  {
    am: "large",
    tex: "{\\large $1 }",
    placeholder: "($1)",
    fill: ["\\text{text}"]
  },
  {
    am: "huge",
    tex: "{\\huge $1 }",
    placeholder: "($1)",
    fill: ["\\text{text}"]
  }
];

// src/symbol-search/modal.ts
var SymbolSearchModal = class extends import_obsidian2.SuggestModal {
  constructor(app, sel, am) {
    super(app);
    this.sel = sel;
    this.am = am;
    this.renderCount = 0;
    this.renderMax = 0;
  }
  getSuggestions(query) {
    query = query.toLowerCase();
    const suggestions = symbols_default.filter((sym) => [sym.am, sym.tex].some((v2) => v2.toLocaleLowerCase().includes(query)));
    this.renderCount = 0;
    this.renderMax = Math.min(suggestions.length, 100);
    return suggestions;
  }
  renderSuggestion(sym, el) {
    this.renderCount++;
    let { am, tex, rendered } = sym;
    el.classList.add("__asciimath-symbol-search-result");
    const text = el.createDiv();
    const amLine = text.createDiv();
    amLine.createSpan({ text: am });
    let toBeRendered = typeof rendered !== "undefined" ? rendered : tex;
    if ("placeholder" in sym) {
      const { placeholder, fill } = sym;
      let template = placeholder;
      if (this.sel) {
        const selToTex = am === "tex" || am === "text" ? this.sel : this.am.toTex(this.sel, { display: false });
        template = template.replace("$1", this.sel);
        tex = tex.replace("$1", selToTex);
        toBeRendered = toBeRendered.replace("$1", selToTex);
      }
      fill.forEach((x, i) => {
        template = template.replace(`$${i + 1}`, x);
        toBeRendered = toBeRendered.replaceAll(`$${i + 1}`, x);
        tex = tex.replaceAll(`$${i + 1}`, x);
      });
      amLine.createSpan({
        text: ` ${template}`,
        cls: "__asciimath-symbol-search-placeholder"
      });
    }
    text.createEl("small", { text: `LaTeX alternative: ${tex}` });
    el.createDiv("__asciimath-symbol-search-preview math", (el2) => {
      if (am === "tex")
        toBeRendered = `tex"${toBeRendered}"`;
      el2.innerHTML = `
        <mjx-container class="MathJax" jax="CHTML">
        ${(0, import_obsidian2.renderMath)(toBeRendered, true).innerHTML}
        </mjx-container>
      `;
      if (this.renderCount >= this.renderMax)
        (0, import_obsidian2.finishRenderMath)();
    });
  }
  onSelected(cb) {
    this.callback = cb;
  }
  onChooseSuggestion(sym) {
    this.callback(sym);
  }
};

// src/symbol-search/modal-instance.ts
function createModalInstance(editor) {
  const sel = editor.getSelection();
  const modal = new SymbolSearchModal(this.app, sel, this.AM);
  modal.setPlaceholder("Start typing AsciiMath or LaTeX symbol name");
  modal.onSelected((sym) => {
    var _a;
    const { am } = sym;
    if ("placeholder" in sym) {
      const { placeholder, fill } = sym;
      let tempExceptFirst = placeholder;
      for (let i = 2; i <= fill.length; i++)
        tempExceptFirst = tempExceptFirst.replace(`$${i}`, "");
      const temp = tempExceptFirst.replace("$1", "");
      if (!sel) {
        const cur = editor.getCursor();
        const placeholder_a_pos = placeholder.indexOf("$1");
        const spacesBefore$1 = ((_a = placeholder.substring(0, placeholder_a_pos).match(/(\$\d+?)/g)) == null ? void 0 : _a.join("").length) || 0;
        editor.replaceSelection(am + temp);
        editor.setCursor({
          line: cur.line,
          ch: cur.ch + am.length + placeholder_a_pos - spacesBefore$1
        });
      } else {
        const placeholder_b_pos = placeholder.indexOf("$2");
        const cur = editor.getCursor("to");
        editor.replaceSelection(am + tempExceptFirst.replace("$1", sel));
        if (placeholder_b_pos !== -1) {
          const $before$2 = placeholder.substring(0, placeholder_b_pos).match(/(\$\d+?)/g);
          const $spacesBefore$2 = ($before$2 == null ? void 0 : $before$2.join("").length) || 0;
          const $2before$1 = !$before$2 || !$before$2.includes("$1") ? sel.length : 0;
          editor.setCursor({
            line: cur.line,
            ch: cur.ch + am.length + placeholder_b_pos - $spacesBefore$2 - $2before$1
          });
        } else {
          editor.setCursor({
            line: cur.line,
            ch: cur.ch + am.length + placeholder.length - 2
          });
        }
      }
    } else {
      editor.replaceSelection(am);
    }
  });
  modal.open();
}

// src/confirm-modal.ts
var import_obsidian3 = require("obsidian");
var ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app) {
    super(app);
  }
  setMessage(message) {
    this.message = message;
    return this;
  }
  setEnableDisplayMode(enableDisplayMode) {
    this.enableDisplayMode = enableDisplayMode;
    return this;
  }
  onConfirm(f2) {
    this.confirmHandler = () => f2(this.enableDisplayMode);
    return this;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Are you sure?");
    new import_obsidian3.Setting(contentEl).setDesc(this.message);
    new import_obsidian3.Setting(contentEl).setName("Enable display mode for each formula").setDesc("This option will insert \\display{ ... } for each formula.").addToggle((toggle) => toggle.setValue(this.enableDisplayMode).onChange((value) => {
      this.enableDisplayMode = value;
    }));
    new import_obsidian3.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Continue").setCta().onClick(() => {
      this.close();
      this.confirmHandler();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/.pnpm/ts-dedent@2.2.0/node_modules/ts-dedent/esm/index.js
function dedent(templ) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var strings = Array.from(typeof templ === "string" ? [templ] : templ);
  strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var indentLengths = strings.reduce(function(arr, str) {
    var matches = str.match(/\n([\t ]+|(?!\s).)/g);
    if (matches) {
      return arr.concat(matches.map(function(match) {
        var _a, _b;
        return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }));
    }
    return arr;
  }, []);
  if (indentLengths.length) {
    var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
    strings = strings.map(function(str) {
      return str.replace(pattern_1, "\n");
    });
  }
  strings[0] = strings[0].replace(/^\r?\n/, "");
  var string = strings[0];
  values.forEach(function(value, i) {
    var endentations = string.match(/(?:^|\n)( *)$/);
    var endentation = endentations ? endentations[1] : "";
    var indentedValue = value;
    if (typeof value === "string" && value.includes("\n")) {
      indentedValue = String(value).split("\n").map(function(str, i2) {
        return i2 === 0 ? str : "" + endentation + str;
      }).join("\n");
    }
    string += indentedValue + strings[i + 1];
  });
  return string;
}
var esm_default = dedent;

// src/convertion.ts
var import_obsidian4 = require("obsidian");
async function convertAsciiMathInFile(plugin, file, display) {
  const view = plugin.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
  if (!view)
    return { block: 0, inline: 0 };
  const { editor } = view;
  const cache = plugin.app.metadataCache.getFileCache(file);
  if (!cache || !cache.sections)
    return { block: 0, inline: 0 };
  const formulaBlocks = [];
  if (cache.sections) {
    for (const section of cache.sections) {
      const { start, end } = section.position;
      if (section.type === "math" || section.type === "code") {
        let content = editor.getRange({ line: start.line, ch: start.col }, { line: end.line, ch: end.col });
        if (section.type === "math") {
          content = content.replace(/^\$\$\s*/, "").replace(/\s*\$\$$/, "");
        }
        if (section.type === "code") {
          const blockReg = new RegExp(`((\`|~){3,})(${plugin.settings.blockPrefix.join("|")})([\\s\\S]*?)\\n\\1`, "m");
          const match = content.match(blockReg);
          if (match)
            content = match[4].trim();
          else
            continue;
        }
        formulaBlocks.push({
          content,
          position: section.position,
          isBlock: true
        });
      } else {
        let content = editor.getRange({ line: start.line, ch: start.col }, { line: end.line, ch: end.col });
        const inlineMathRegex = /(?<!\$)\$([^$]+?)\$(?!\$)/g;
        let inlineMatch;
        while ((inlineMatch = inlineMathRegex.exec(content)) !== null) {
          const relativeStart = inlineMatch.index;
          const relativeEnd = relativeStart + inlineMatch[0].length;
          const absoluteStart = section.position.start.offset + relativeStart;
          const absoluteEnd = section.position.start.offset + relativeEnd;
          const startPos = editor.offsetToPos(absoluteStart);
          const endPos = editor.offsetToPos(absoluteEnd);
          const amCode = inlineMatch[1].trim();
          if (isLatexCode(amCode))
            continue;
          formulaBlocks.push({
            position: {
              start: { line: startPos.line, col: startPos.ch, offset: absoluteStart },
              end: { line: endPos.line, col: endPos.ch, offset: absoluteEnd }
            },
            content: amCode,
            isBlock: false
          });
        }
      }
    }
    const changes = [];
    formulaBlocks.forEach((block) => {
      const { start, end } = block.position;
      const res = toTex(plugin.AM, block.content, display);
      const replacement = block.isBlock ? `$$
${res}
$$` : `$${res}$`;
      changes.push({
        from: { line: start.line, ch: start.col },
        to: { line: end.line, ch: end.col },
        text: replacement
      });
    });
    editor.transaction({ changes });
    new import_obsidian4.Notice(`Conversion completed: ${formulaBlocks.length} formulas processed`);
  }
  return {
    block: formulaBlocks.filter((x) => x.isBlock).length,
    inline: formulaBlocks.filter((x) => !x.isBlock).length
  };
}
async function extractFormulasInFile(plugin, file) {
  const content = await plugin.app.vault.read(file);
  const formulas = [];
  const codeRanges = [];
  const codeBlockRegex = /(^|\n)(```|~~~)[\s\S]*?\2/g;
  const amCodeBlockRegex = new RegExp(`([\`~]{3,})(${plugin.settings.blockPrefix.join("|")})([\\s\\S]*?)\\n\\1`, "m");
  const inlineCodeRegex = /`[^`\n]*`/g;
  for (const match of content.matchAll(codeBlockRegex)) {
    const am = match[0].match(amCodeBlockRegex);
    codeRanges.push({
      start: match.index,
      end: match.index + match[0].length,
      isAm: am !== null
    });
    if (am) {
      const amCode = am[3];
      let start = match.index;
      if (match[1] === "\n") {
        start += 1;
      }
      formulas.push({
        type: "block",
        start,
        end: match.index + match[0].length,
        content: amCode
      });
    }
  }
  for (const match of content.matchAll(inlineCodeRegex)) {
    codeRanges.push({
      start: match.index,
      end: match.index + match[0].length,
      isAm: false
    });
  }
  const inlineRegex = /(?<![\\\$])\$([^$]+?)\$/g;
  const blockRegex = /(?<!\\)\$\$([\s\S]+?)\$\$/g;
  for (const match of content.matchAll(inlineRegex)) {
    if (!isLatexCode(match[1])) {
      formulas.push({
        type: "inline",
        start: match.index,
        end: match.index + match[0].length,
        content: match[1].trim()
      });
    }
  }
  for (const match of content.matchAll(blockRegex)) {
    if (!isLatexCode(match[1])) {
      formulas.push({
        type: "block",
        start: match.index,
        end: match.index + match[0].length,
        content: match[1].trim()
      });
    }
  }
  return formulas.filter((formula) => {
    return !codeRanges.some((range) => formula.start >= range.start && formula.end <= range.end && !range.isAm);
  });
}
async function replaceFormulasInFile(plugin, file, enableDisplayMode) {
  const content = await plugin.app.vault.read(file);
  const formulas = await extractFormulasInFile(plugin, file);
  console.log({ formulas });
  formulas.sort((a, b2) => b2.start - a.start);
  let newContent = content;
  const convertedCnt = { block: 0, inline: 0 };
  for (const formula of formulas) {
    if (isLatexCode(formula.content)) {
      continue;
    }
    const converted = toTex(plugin.AM, formula.content.trim(), enableDisplayMode);
    const replacement = formula.type === "inline" ? `$${converted}$` : `$$${converted}$$`;
    newContent = newContent.substring(0, formula.start) + replacement + newContent.substring(formula.end);
    convertedCnt[formula.type] += 1;
  }
  await plugin.app.vault.modify(file, newContent);
  return convertedCnt;
}
function actionConvertActiveFile(plugin, message) {
  return async () => new ConfirmModal(plugin.app).setMessage(message).setEnableDisplayMode(false).onConfirm(async (displayMode) => {
    const file = plugin.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian4.Notice("No active file found.");
      return;
    }
    await convertAsciiMathInFile(plugin, file, displayMode);
  }).open();
}
function actionConvertEntireVault(plugin, message) {
  return async () => new ConfirmModal(plugin.app).setMessage(message).setEnableDisplayMode(false).onConfirm(async (displayMode) => {
    const allConvertionRes = await Promise.all(plugin.app.vault.getMarkdownFiles().map(async (f2) => {
      const convertionRes = await replaceFormulasInFile(plugin, f2, displayMode);
      return {
        ...convertionRes,
        hasAsciimath: convertionRes.block || convertionRes.inline
      };
    }));
    const lo = { block: 0, inline: 0, fileNum: 0 };
    allConvertionRes.forEach((res) => {
      if (res.hasAsciimath) {
        lo.block += res.block;
        lo.inline += res.inline;
        lo.fileNum += 1;
      }
    });
    new import_obsidian4.Notice(`Converted ${lo.block} blocks and ${lo.inline} inline formulas in ${lo.fileNum} file${lo.fileNum > 1 ? "s" : ""}.`);
  }).open();
}

// src/commands.ts
function initCommands(plugin) {
  const commands = [
    {
      id: "asciimath-insert-symbol",
      icon: "sigma",
      name: "View AsciiMath symbols",
      editorCallback: (editor) => {
        createModalInstance(editor);
      }
    },
    {
      id: "insert-asciimath-block",
      name: "Insert asciimath block",
      editorCallback: (editor, _view) => {
        editor.replaceSelection(`\`\`\`${plugin.settings.blockPrefix[0] || "asciimath"}
${editor.getDoc().getSelection()}
\`\`\``);
        const cursor = editor.getCursor();
        editor.setCursor(cursor.line - 1);
      }
    },
    {
      id: "convert-selected-to-latex",
      name: "Convert exact selection into LaTeX",
      editorCallback: (editor, _view) => {
        const cursorStart = editor.getCursor("from");
        const cursorEnd = editor.getCursor("to");
        const amCode = editor.getSelection();
        const doConvert = () => editor.replaceRange(plugin.AM.toTex(amCode), cursorStart, cursorEnd);
        if (amCode.length > 1e3) {
          new ConfirmModal(plugin.app).setMessage(esm_default`The selection is over 1000 chars.
                     Please confirm that you have selected the exact AsciiMath expression.
                     Click the Continue button to convert though.`).onConfirm(doConvert).open();
        } else if (isLatexCode(amCode)) {
          new ConfirmModal(plugin.app).setMessage(esm_default`The selection may be already LaTeX.
                   Click the Continue buttom to convert though.`).onConfirm(doConvert).open();
        } else {
          doConvert();
        }
      }
    },
    {
      id: "convert-am-block-into-mathjax-in-current-file",
      name: "Convert AsciiMath to LaTeX (active file)",
      callback: actionConvertActiveFile(plugin, "This will replace all AsciiMath blocks with LaTeX math blocks in the active file. THIS ACTION CANNOT BE UNDONE.")
    },
    {
      id: "convert-am-block-into-mathjax-in-vault",
      name: "Convert AsciiMath to LaTeX (entire vault)",
      callback: actionConvertEntireVault(plugin, "This will replace all AsciiMath formulas with LaTeX math blocks in the entire vault. THIS ACTION CANNOT BE UNDONE.")
    }
  ];
  commands.forEach((command) => {
    plugin.addCommand(command);
  });
}

// src/main.ts
var DEFAULT_SETTINGS = {
  blockPrefix: ["asciimath", "am"],
  disableDeprecationWarning: false,
  replaceMathBlock: true,
  customSymbols: []
};
var AsciiMathPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.existPrefixes = [];
    this.postProcessors = /* @__PURE__ */ new Map();
  }
  calcSymbols() {
    return this.settings.customSymbols.map(([k2, v2]) => {
      return [k2, { type: m.Const, tex: v2 }];
    });
  }
  onunload() {
    console.log("Obsidian asciimath unloaded");
    MathJax.tex2chtml = this.tex2chtml;
    this.unregister();
  }
  unregister() {
    this.postProcessors.forEach((value) => {
      import_obsidian5.MarkdownPreviewRenderer.unregisterPostProcessor(value);
    });
    this.postProcessors.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  setupMathBlockRendering() {
    this.tex2chtml = MathJax.tex2chtml;
    if (this.settings.replaceMathBlock)
      MathJax.tex2chtml = (s, r) => this.convertMathCode(s, r);
    else
      MathJax.tex2chtml = this.tex2chtml;
  }
  convertMathCode(source, r) {
    if (this.settings.replaceMathBlock && !isLatexCode(source))
      source = this.AM.toTex(source);
    return this.tex2chtml(source, r);
  }
  registerAsciiMathCodeBlock(prefix) {
    this.postProcessors.set(prefix, this.registerMarkdownCodeBlockProcessor(prefix, (src, el, ctx) => this.postProcessor(prefix, src, el, ctx)));
  }
  postProcessor(_prefix, src, el, _2) {
    const mathEl = (0, import_obsidian5.renderMath)(src, true);
    el.appendChild(mathEl);
    (0, import_obsidian5.finishRenderMath)();
  }
  async onload() {
    await this.loadSettings();
    await (0, import_obsidian5.loadMathJax)();
    this.AM = new F({
      symbols: this.calcSymbols()
    });
    if (!MathJax) {
      console.warn("MathJax was not defined despite loading it.");
      new import_obsidian5.Notice("Error: MathJax was not defined despite loading it!");
      return;
    }
    initCommands(this);
    this.postProcessors = /* @__PURE__ */ new Map();
    this.app.workspace.onLayoutReady(async () => {
      this.settings.blockPrefix.forEach((prefix) => {
        this.registerAsciiMathCodeBlock(prefix);
        this.existPrefixes.push(prefix);
      });
    });
    this.setupMathBlockRendering();
    this.addSettingTab(new AsciiMathSettingTab(this.app, this));
    console.log("Obsidian asciimath loaded");
  }
};

/* nosourcemap */